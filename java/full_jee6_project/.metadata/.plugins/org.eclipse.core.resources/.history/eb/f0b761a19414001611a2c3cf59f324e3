package br.com.devnagui.project.manager.impl;

import java.util.Date;
import java.util.List;

import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;

import org.apache.log4j.Logger;

import br.com.devnagui.project.dto.PaginaDTO;
import br.com.devnagui.project.entities.PostoCombustivel;
import br.com.devnagui.project.entities.Rota;
import br.com.devnagui.project.entities.RotaVersao;
import br.com.devnagui.project.enums.StatusRotaVersao;
import br.com.devnagui.project.manager.RotaManager;
import br.com.devnagui.project.manager.RotaVersaoManager;
import br.com.devnagui.project.manager.exception.BusinessException;

@Stateless
public class RotaVersaoManagerBean extends GenericoManagerBean<RotaVersao> implements RotaVersaoManager {

	/**
	 * Serial UID.
	 */
	private static final long serialVersionUID = -6493579600927150528L;
	
	private static final Logger LOG = Logger.getLogger(RotaVersaoManager.class);

	@EJB private RotaManager rotaManager;

	/**
	 * Método que pode alterar uma rota, caso ela não tenha nenhuma rota versão
	 * ativa ou desativada. Caso você tenha alguma rota versão em edição só será
	 * alterado, mas caso você tenha uma ativa será criado uma nova rota versão.
	 * 
	 * @param rotaVersao
	 * @param rota
	 * @return RotaVersao
	 * @throws BusinessException
	 */
	@Override
	public RotaVersao alterarRotaOuInserirRotaVersao(RotaVersao rotaVersao, Rota rota) throws BusinessException {
		// Lógica inversa, pois se não tiver alguma versão ativa ou desativada vai ser true.
		if(temVersaoAtivaOuDesativada(rota.getId()) && rotaVersao.getStatus() != 2) {
			// Preciso setar pata NULL, pois eu vou inserir outro dado no banco.
			rotaVersao.setId(null);
			// Default é o 2 - Em Edição, pois tem que ficar em edição.
			rotaVersao.setStatus(StatusRotaVersao.EM_EDICAO.getCodigoSituacao());
			rotaManager.validarCamposAlterar(rota);
			this.validarCampos(rotaVersao);
		} else if(temVersaoAtivaOuDesativada(rota.getId()) && rotaVersao.getStatus() == 2) { 
			rotaManager.validarCamposAlterar(rota);
			this.validarCampos(rotaVersao);
		} else {
			if(rotaVersao.getRota().getNumero() == rotaManager.buscar(rotaVersao.getRota().getId()).getNumero()) {
				rotaManager.validarCamposAlterar(rota);
				this.validarCampos(rotaVersao);
			} 
		}
		
		// Eu estou garantindo que este campo que será nulo.
		rotaVersao.setDataDesativacao(null);
		rotaVersao.setRota(rota);
		return super.alterar(rotaVersao);
	}
	
	/**
	 * Método que ativa um rota versão em edição.
	 * 
	 * @param rotaVersao
	 * @throws BusinessException
	 */
	@Override
	public void ativar(RotaVersao rotaVersaoEmEdicao, RotaVersao rotaVersaoAtiva) throws BusinessException {
		if(rotaVersaoAtiva != null) {
			rotaVersaoEmEdicao.setStatus(StatusRotaVersao.ATIVA.getCodigoSituacao());
			rotaVersaoAtiva.setStatus(StatusRotaVersao.DESATIVADA.getCodigoSituacao());
			rotaVersaoAtiva.setDataDesativacao(new Date());
			this.alterar(rotaVersaoAtiva);
			this.alterar(rotaVersaoEmEdicao);
		} else {
			rotaVersaoEmEdicao.setStatus(StatusRotaVersao.ATIVA.getCodigoSituacao());
			this.alterar(rotaVersaoEmEdicao);
		}
	}

	/**
	 * Método que faz o desfazer a rota versão, tira do estado ativo a que está 
	 * tranzendo para em edição e a última que foi desativada traz para ativo.
	 * 
	 * @param rotaVersao
	 * @throws BusinessException
	 */
	@Override
	public void desfazer(RotaVersao rotaVersaoDesativada, RotaVersao rotaVersaoAtiva) throws BusinessException {
		if(rotaVersaoDesativada != null) {
			rotaVersaoDesativada.setStatus(StatusRotaVersao.ATIVA.getCodigoSituacao());
			rotaVersaoDesativada.setDataDesativacao(null);
			this.alterar(rotaVersaoDesativada);
		}
		rotaVersaoAtiva.setStatus(StatusRotaVersao.EM_EDICAO.getCodigoSituacao());
		this.alterar(rotaVersaoAtiva);
	}

	/**
	 * Método que desativa todas as rotas versões tanto a rota versão ativa quanto
	 * a rota versão em edição.
	 * 
	 * @param rotaVersao
	 * @throws BusinessException
	 */
	@Override
	public void desativar(Rota rota) throws BusinessException {
		List<RotaVersao> rotaVersoes = this.buscaVersaoAtivaEEmEdicao(rota.getId());
		
		for (RotaVersao rotaVersao : rotaVersoes) {
			rotaVersao.setStatus(StatusRotaVersao.DESATIVADA.getCodigoSituacao());
			this.alterar(rotaVersao);
		}
	}

	/**
	 * Método que busca pelo menos uma versão da rota ativa ou desativada, caso
	 * tenha o usuário não pode mudar nem o número e nome da rota.
	 * 
	 */
	@Override
	public Boolean temVersaoAtivaOuDesativada(Long idRota) {
		LOG.info("Obtendo rota versão ativa ou desativada");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_BUSCA_VERSAO_ATIVA_OU_DESATIVADA, RotaVersao.class);
		query.setParameter("idRota", idRota);

		if (!query.getResultList().isEmpty())
			return true;
		else
			return false;
	}

	/**
	 * Método que busca uma rota versão ativa ou em endição, pelo id passado
	 * para a tela de Alterar ROTA. De acordo com a regra de negócio, pois se eu
	 * tiver uma versão ativa você ultiliza ela como base para criar uma em
	 * edição, mas porém se você tiver uma ativa e uma ativa você pega como base
	 * a em edição, assim você não ira usar ativa como base e sem a em edição. 
	 * 1 = Ativo. 2 = Em Edição.
	 * 
	 * @param idRota
	 * @return RotaVersao
	 */
	@Override
	public RotaVersao buscaVersaoAtivaOuEmEdicao(Long idRota) {
		LOG.info("Obtendo rota versão ativa ou em edição");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_BUSCA_VERSAO_ATIVA_OU_EM_EDICAO, RotaVersao.class);
		query.setParameter("idRota", idRota);

		// Sempre irá sempre pegar o 1º, pois se tiver 1 ativa vai ser essa e se
		// tiver uma em edição vai ser essa e se tiver tiver tanto ativa e eem edição
		// vai ser a em edição pois a consulta está DESC.
		return query.getResultList().get(0);
	}

	/**
	 * Método que busca todas as rotas versão ativas e em edição daquela rota.
	 * 
	 * @param idRota
	 * @return RotaVersao
	 */
	@Override
	public List<RotaVersao> buscaVersaoAtivaEEmEdicao(Long idRota) {
		LOG.info("Obtendo rota versão ativa ou em edição");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_BUSCA_VERSAO_ATIVA_E_EM_EDICAO, RotaVersao.class);
		query.setParameter("idRota", idRota);

		if (!query.getResultList().isEmpty())
			return query.getResultList();
		else
			return null;
	}

	/**
	 * Método que lista todas as rotas versão ativas do sistema.
	 * 
	 * @return RotaVersao
	 */
	@Override
	public List<RotaVersao> listaVersaoAtiva() {
		LOG.info("Obtendo as rotas versões ativas");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_LISTAR_VERSOES_ATIVAS, RotaVersao.class);

		if (!query.getResultList().isEmpty())
			return query.getResultList();
		else
			return null;
	}
	
	/**
	 * Método que busca todas rotas versões ativas daquela rota.
	 * 
	 */
	@Override
	public RotaVersao buscaVersaoAtiva(Long idRota) {
		LOG.info("Obtendo rota versão ativa");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_BUSCA_VERSAO_ATIVA, RotaVersao.class);
		query.setParameter("idRota", idRota);

		if (!query.getResultList().isEmpty())
			return query.getSingleResult();
		else
			return null;
	}

	/**
	 * Método que busca todas rotas versões em edição daquela rota.
	 * 
	 */
	@Override
	public RotaVersao buscaVersaoEmEdicao(Long idRota) {
		LOG.info("Obtendo rota versão em edição");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_BUSCA_VERSAO_EM_EDICAO, RotaVersao.class);
		query.setParameter("idRota", idRota);

		if (!query.getResultList().isEmpty())
			return query.getSingleResult();
		else
			return null;
	}

	@Override
	public RotaVersao buscaVersaoDesativada(Long idRota) {
		LOG.info("Obtendo rota versão desativada");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_BUSCA_VERSAO_DESATIVADA, RotaVersao.class);
		query.setParameter("idRota", idRota);

		if (!query.getResultList().isEmpty())
			return query.getResultList().get(0);
		else
			return null;
	}
	
	/**
	 * Método que busca todas rotas versões daquela rota.
	 * 
	 */
	@Override
	public List<RotaVersao> buscaVersoes(Long idRota) {
		LOG.info("Obtendo versões da rota");
		TypedQuery<RotaVersao> query = getEntityManager().createNamedQuery(RotaVersao.QUERY_BUSCA_VERSOES, RotaVersao.class);
		query.setParameter("idRota", idRota);
		return query.getResultList();
	}

	/**
	 * Método que verifica se o novo posto que eu estou inserindo já está na
	 * lista.
	 * 
	 * @return Boolean
	 */
	@Override
	public Boolean isValidarListaPostosRepetidos(List<PostoCombustivel> postos, PostoCombustivel postoCombustivel) {
		if (postos.contains(postoCombustivel))
			return true;
		else
			return false;
	}

	/**
	 * Método que valida todos os campos da rota versão.
	 * 
	 * @param rotaVersao
	 * @throws BusinessException
	 */
	@Override
	public void validarCampos(RotaVersao rotaVersao) throws BusinessException {
		LOG.info("Iniciando validação de campos.");
		this.validarDuracao(rotaVersao.getDuracao());
		this.validarObservacao(rotaVersao.getObservacao());
		this.validarListaPostos(rotaVersao.getPostoCombustiveis());
		this.validarStatus(rotaVersao.getStatus());
		this.validarRota(rotaVersao.getRota());
	}

	/**
	 * Método que valida o campo duração que não pode ter mais que 3 digitos.
	 * 
	 * @param duracao
	 * @throws BusinessException
	 */
	@Override
	public void validarDuracao(Integer duracao) throws BusinessException {
		if(duracao == null)
			throw new BusinessException("mensagem.rota.versao.duracao.null");
		else if(duracao <= 0)
			throw new BusinessException("mensagem.rota.versao.duracao.igual.zero");
		else if(duracao > 999)
			throw new BusinessException("mensagem.rota.versao.duracao.maior");
	}

	
	/**
	 * Método que valida o campo observação de Rota Versão.
	 * 
	 * @param observacao
	 * @throws BusinessException
	 */
	@Override
	public void validarObservacao(String observacao) throws BusinessException {
		if (observacao.length() > 300)
			throw new BusinessException("mensagem.rota.versao.obersavao.maior");
	}

	/**
	 * Método que valida a lista de postos de combustíveis de Rota Versão.
	 * 
	 * @param postos
	 * @throws BusinessException
	 */
	@Override
	public void validarListaPostos(List<PostoCombustivel> postos) throws BusinessException {
		if (postos == null)
			throw new BusinessException("mensagem.rota.versao.lista.posto.null");
		else if (postos.isEmpty())
			throw new BusinessException("mensagem.rota.versao.lista.posto.vazia");
	}

	/**
	 * Método que valida o status da Rota Versão.
	 * 
	 * @param status
	 * @throws BusinessException
	 */
	@Override
	public void validarStatus(Integer status) throws BusinessException {
		if (status == null)
			throw new BusinessException("mensagem.rota.versao.status.null");
		else if (status <= 1 || status >= 3)
			throw new BusinessException("mensagem.rota.versao.status.opicoes");
	}

	/**
	 * Método que valida a rota da Rota Versão, pois não pode está null.
	 * 
	 * @param rota
	 * @throws BusinessException
	 */
	@Override
	public void validarRota(Rota rota) throws BusinessException {
		if (rota == null)
			throw new BusinessException("mensagem.rota.versao.rota.null");
	}

	@Override
	public PaginaDTO<RotaVersao> obterListaPaginadaDeRotasVersoesAtivas(
			PaginaDTO<RotaVersao> paginaAtual) throws BusinessException {
		CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();
		CriteriaQuery<RotaVersao> cQuery = builder.createQuery(getEntityClass());
		Root<RotaVersao> entidadeRoot = cQuery.from(getEntityClass());

		cQuery.select(entidadeRoot);
		Predicate clausulaWhere = construirCondicoesWhereApenasRotasAtivas(builder, entidadeRoot
		        );
		cQuery.where(clausulaWhere);
		cQuery.orderBy(construirOrderBy(builder, entidadeRoot ,paginaAtual));

		List<RotaVersao> dadosPaginados = recuperarDadosPaginados(paginaAtual);
		paginaAtual.setDados(dadosPaginados);

		int quantidadeTotalRegistros = obterQuantidadeTotalRegistros(paginaAtual);
		paginaAtual.setTotalRegistros(quantidadeTotalRegistros);
		return paginaAtual;
	}
	
    @SuppressWarnings("unused")
	private int obterQuantidadeTotalRegistros(Predicate clausulaWhere, PaginaDTO<RotaVersao> paginaAtual) {
        CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();
        CriteriaQuery<Long> cQuery = builder.createQuery(Long.class);
        Root<RotaVersao> entidadeRoot = cQuery.from(getEntityClass());
        clausulaWhere.alias( entidadeRoot.getAlias());
        cQuery.select(builder.count(entidadeRoot));
        cQuery.where(clausulaWhere);
        Long quantidadeTotalRegistros = getEntityManager().createQuery(cQuery).getSingleResult();
        return quantidadeTotalRegistros.intValue();
    }

    public Predicate construirCondicoesWhereApenasRotasAtivas(CriteriaBuilder builder2, Root<RotaVersao> entidadeRoot2) {
        CriteriaQuery<RotaVersao> cQuery = builder2.createQuery(getEntityClass());
        Path<Object> statusRota = entidadeRoot2.get("status");
        return builder2.equal(statusRota, StatusRotaVersao.ATIVA.getCodigoSituacao());
    }
}